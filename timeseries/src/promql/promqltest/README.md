# PromQL Test Framework

Implements a Prometheus-inspired promqltest DSL for validating PromQL semantics.

## Architecture

The test framework is organized into focused modules with clear separation of concerns:

```
promqltest/
├── dsl.rs        # Parse test commands (load, eval, clear, ignore, resume)
├── loader.rs     # Load series data into TSDB
├── evaluator.rs  # Execute PromQL queries and return results
├── assert.rs     # Compare actual vs expected results
├── runner.rs     # Orchestrate test execution
└── testdata/     # Test files (*.test)
```

### Execution Flow

```
run_all_promql_tests() (mod.rs)
    ↓
run_builtin_tests() (runner.rs)
    ↓
discover_test_files() → *.test files in testdata/
    ↓
parse_test_file() (dsl.rs) → Command objects
    ↓
run_test_with_storage() (runner.rs) → execute each command
    ├─→ load_series() (loader.rs) → ingest data
    ├─→ eval_instant() (evaluator.rs) → execute query
    └─→ assert_results() (assert.rs) → compare results
```

### Module Responsibilities

- **dsl.rs**: Parse test commands (`load`, `eval`, `clear`, `ignore`, `resume`)
- **loader.rs**: Convert step-based test data to timestamps and ingest into TSDB
- **evaluator.rs**: Execute PromQL queries via the query router
- **assert.rs**: Compare results with flexible label matching
- **runner.rs**: Orchestrate test execution, manage TSDB lifecycle

### Parser Design

- The test DSL parser parses only test commands.
- PromQL expressions are parsed by the same `promql_parser` crate used by the application.
- This ensures test evaluation uses identical query parsing logic as production code.

## Adding New Tests

Create a `.test` file in `testdata/` - it's automatically discovered at build time.

1. Create `testdata/my_feature.test`
2. Run tests - a `should_pass_my_feature()` function is auto-generated

Tests are generated by `build.rs` which scans `testdata/*.test` files.

## Running Tests

```bash
# Run all promql tests
cargo test -p opendata-timeseries promql::promqltest::tests

# Run a specific test file
cargo test -p opendata-timeseries promql::promqltest::tests::should_pass_at_modifier
```

## Test File Format

The test format follows [Prometheus's promqltest specification](https://prometheus.io/docs/prometheus/latest/configuration/unit_testing_rules/) with two extensions: the `ignore` and `resume` directives.

### Ignore and Resume Directives

The `ignore` directive skips all subsequent commands until `resume` or `clear`. This allows copying test files directly from Prometheus's test suite while marking unimplemented features.

```
# Working features
load 5m
  metric 1 2 3

eval instant at 5m
  metric
    {} 2

# Not yet implemented
ignore

eval instant at 5m
  unimplemented_function(metric)
    {} 42

# Resume testing with same data
resume

eval instant at 10m
  metric
    {} 3
```

**Behavior**:
- `ignore` - Skip all subsequent commands
- `resume` - Stop skipping
- `clear` - Wipe all loaded data (doesn't affect ignore state)

This helps identify the percentage of Prometheus test coverage without modifying upstream test files.

### All Commands

- `load <interval>` - Load time series at specified interval
- `eval instant at <time>` - Execute instant query at timestamp
- `clear` - Wipe all loaded data (doesn't affect ignore state)
- `ignore` - Skip all subsequent commands
- `resume` - Stop skipping commands

## Reference

Based on Prometheus promqltest: https://github.com/prometheus/prometheus/tree/main/promql/promqltest
